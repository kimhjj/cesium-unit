<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <!-- Include the CesiumJS JavaScript and CSS files -->
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.104/Build/Cesium/Cesium.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.104/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <style>
        body {
            margin: 0px;
            padding: 0px;
            height: 100%;
        }
        .content {
            position: absolute;
            top: 0px;
            width: calc(100% - 40px);
            height: 120px;
            padding: 20px;
        }
        .button {
            margin: 2px 2px 2px 0;
        }
        .active.terrain {
            background-color: tomato;
        }
        .active.move {
            background-color: cadetblue;
        }

        #cesiumContainer {
            position: absolute;
            top: 120px;
            width: 100%;
            height: calc(100% - 120px);
        }

    </style>
</head>

<body>
    <div class="content">
		<div>12km</div>
    </div>
    <div id="cesiumContainer"></div>
    <script>
        
        Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIzYTM3ODhlNC1jOWUxLTRhOTYtYTgwZC1iMDA3OGJiMTQwZDciLCJpZCI6MTI5NDU5LCJpYXQiOjE2ODIwNTc4NjN9.GC-W9QfAFa9rXMh2Ow2rSC5UvLcwtS_qjWJ1v454z1A';
		
		const ABSOLUTE_ZERO = 273.15;
        const viewer = new Cesium.Viewer('cesiumContainer');
        viewer.scene.globe.depthTestAgainstTerrain = true;
			
		// 1. 큐브를 그린다. 원점에서 12km 간격 이동
		//		원점은 목포쪽이다. x값이 증가하고, 증가가 끝나면 y값이 증가한다.
		// 2. 먼저 큐브를 그려보자. 높이는 5000~5400 - 4300~4500 으로 설정한다.

		let dataGrid = {};
		const makeDataGrid = async () => {	
			
			const keys = [
				["hgt", "500"],
				["hgt", "600"],
				["hgt", "700"],
				["hgt", "800"],
				["tmp", "500"],
				["tmp", "600"],
				["tmp", "700"],
				["tmp", "800"],
			]
			
			const promises = keys.map(async ([key, value]) => {
				if(!dataGrid[value]) {
					dataGrid[value] = {};
				}
				
				return await readDataGrid(key, value).then((array)=>[key, value, array]);
				 
			});
			
			const results = await Promise.all(promises);
			results.forEach(([key, value, array]) => dataGrid[value][key] = array);
		}
		
		const readDataGrid = async (key, height) => {
			const data = await fetch(`./data/g120${key}${height}.txt`);
			const text = await data.text();
			return text.split("\n");
		}
		
		const drawCube = () => {
			const [startX, startY] = [101.577323, 12.217029];
			const [gridX, gridY] = [491, 419]; // 고정값
			const [minX, minY] = [220, 220]; // 나중에 [0,0]으로 변경
			const [maxX, maxY] = [350, 350]; // 나중에 [491, 419]으로 변경
			
			const distance = 12000;
			const position = Cesium.Cartesian3.fromDegrees(startX, startY);
			
			const hpaList = [500,600,700];
			hpaList.forEach((hpa) => {
			
				for(let y = minY; y < maxY; y++) {
					let calcY = addY(position, distance*y);
					
					for(let x = minX; x < maxX; x++) {
						let calcX = addX(position, distance*x);
						
						const currentCell = (y * gridX) + (x);
						
						const tmp = Number(dataGrid[hpa]["tmp"][currentCell]);
						const upperHeight = Number(dataGrid[hpa]["hgt"][currentCell]);
						const underHeight = Number(dataGrid[hpa+100]["hgt"][currentCell]);
						const diffHeight = upperHeight - underHeight;
						
						viewer.entities.add({
							position: Cesium.Cartesian3.fromDegrees(calcX.lon, calcY.lat, upperHeight),
							box: {
								dimensions: new Cesium.Cartesian3(distance, distance, diffHeight),
								material: getColor(tmp - ABSOLUTE_ZERO),
							},
						});
					}
				}
			})
		}
		
		const addY = (position, distance) => {
			let northVector = new Cesium.Cartesian3(0, 0, distance);
			return getPositionByVector(position, northVector);
		}

		const addX = (position, distance) => {
			let eastVector = new Cesium.Cartesian3(distance * (-1), 0, 0);
			return getPositionByVector(position, eastVector);
		}
		
		const getPositionByVector = (position, vector) => {
			let newPosition = Cesium.Cartesian3.add(position, vector, new Cesium.Cartesian3());
			let newCartographic = Cesium.Cartographic.fromCartesian(newPosition);
			let newLongitude = Cesium.Math.toDegrees(newCartographic.longitude);
			let newLatitude = Cesium.Math.toDegrees(newCartographic.latitude);
			
			return {lon: newLongitude, lat: newLatitude};
		}
		
		const getColor = (value) => {
			let color = null;
			let alpha = 0.3;
			
			if(10 <= value) {
				color = Cesium.Color.RED.withAlpha(alpha);
			} else if(0 <= value && value < 10) {
				color = Cesium.Color.SANDYBROWN.withAlpha(alpha);
			} else if(-1 <= value && value < 0) {
				color = Cesium.Color.LEMONCHIFFON.withAlpha(alpha);
			} else if(-2 <= value && value < -1) {
				color = Cesium.Color.LAWNGREEN.withAlpha(alpha);
			} else if(-3 <= value && value < -2) {
				color = Cesium.Color.LIGHTBLUE.withAlpha(alpha);
			} else {
				color = Cesium.Color.INDIGO.withAlpha(alpha);
			}
			
			return color;
		}
		
        const flyTo = (target) => {
            const positionList = {
                'ko': { 
                    x: -3692960.9010914317,
                    y: 5521059.97524565,
                    z: 3916491.0511800093,
                    h: 0.2650252972560132,
                    p: -1.143294535614582,
                    r: 0.00023341358505302168
                },
                'g120': { 
                    x: -4297592.334571193, 
					y: 11726991.900281686, 
					z: 1239175.8912950524,
                    h: 0.12748782524444469,
                    p: -1.1839935226361527,
                    r: 0.001979041395128611
                }
            }
            
            const position = positionList[target];
            viewer.camera.flyTo({
                destination : new Cesium.Cartesian3(position.x, position.y,  position.z),
                orientation: {heading: position.h, pitch: position.p, roll: position.r}
            });
        }

        // load
        flyTo('ko');
		makeDataGrid().then(()=>{
			drawCube();
		});

    </script>
    </div>
</body>

</html>